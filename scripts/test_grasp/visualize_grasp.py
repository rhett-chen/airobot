import numpy as np
import cv2
import os
import airobot.utils.common as common
import mayavi.mlab as mlab
import trimesh
from options import make_parser
from util import *


def get_color_plasma(x):
    return tuple([float(1 - x), float(x), float(0)])


def get_color_for_pc(pc, K, color_image):
    proj = pc.dot(K.T)
    proj[:, 0] /= proj[:, 2]
    proj[:, 1] /= proj[:, 2]

    pc_colors = np.zeros((pc.shape[0], 3), dtype=np.uint8)
    for i, p in enumerate(proj):
        x = int(p[0])
        y = int(p[1])
        pc_colors[i, :] = color_image[y, x, :]

    return pc_colors


def get_grasp_points(pc_gripper_version='customized'):
    """
       grasp points cloud contain 7 points, during visualization, the 7 points will be connected in sequence to form a
    shape of gripper.
    Args:
        pc_gripper_version: customized | panda
                                 |  ^  |   <- top is two contact points, ^ is center of two contact points
            gripper figure:      |_____|   <- line
                                    |
                                    !     <- bottom is bottom point
          customized_grasp_points.npy: the center of two contact points is at [0, 0, 0],
                two contact points are [0.037, 0, 0] [-0.037, 0, 0]
                line: [0.037, 0, -0.046], [-0.037, 0, -0.046]
                bottom point: [0, 0, -0.105]
          panda.npy: contact point: [0.0526874, 0, 0.10527] [-0.0526874, 0, 0.10527]
                the center of two contact points is at [0, 0, 0.10527],
                line: [0.0526874, 0, 0.059] [-0.0526874, 0, 0.059]
                bottom point: [0, 0, 0]
         For the above two files, the two-fingers plane is x-z plane.
         For customized version, center (two contact points center) is [0, 0, 0], bottom point is [0, 0, -0.105]
         For panda version, bottom point is [0, 0, 0], center of two contact points is [0, 0, 0.10527];
            grasp poses generate by GPNet: pos is center of two contact points;
            grasp poses generated by 6dof-grapsnet: pos is bottom point of panda, deviation of 0.10527 from the center
         of two contacted points along approaching vector;  These two problems have been dealt with in main()unction
    Returns: grasp points shape [7, 3]
    """
    if pc_gripper_version == 'panda':
        control_points = np.array([[0.00000000e+00, 0.00000000e+00, 0.00000000e+00],
                          [0.00000000e+00, 0.00000000e+00, 5.90000004e-02],
                          [5.26874326e-02, -5.99553132e-05, 5.90000004e-02],
                          [5.26874326e-02, -5.99553132e-05, 1.05273142e-01],
                          [5.26874326e-02, -5.99553132e-05, 5.90000004e-02],
                          [-5.26874326e-02, 5.99553132e-05, 5.90000004e-02],
                          [-5.26874326e-02, 5.99553132e-05, 1.05273142e-01]])
    elif pc_gripper_version == 'customized':
        control_points = np.array([[0., 0., -0.105], [0., 0., -0.046], [0.037, 0, -0.046], [0.037, 0, 0.],
                                   [0.037, 0, -0.046], [-0.037, 0, -0.046], [-0.037, 0, 0.]])
    else:
        raise NotImplementedError
    return control_points


def plot_mesh(mesh):
    assert type(mesh) == trimesh.base.Trimesh
    mlab.triangular_mesh(mesh.vertices[:, 0],
                         mesh.vertices[:, 1],
                         mesh.vertices[:, 2],
                         mesh.faces,
                         colormap='Blues')


def draw_scene(args,
               pc,
               grasps=None,
               grasp_scores=None,
               grasp_color=None,
               gripper_color=(0, 1, 0),
               mesh=None,
               show_gripper_mesh=False,
               grasps_selection=None,
               visualize_diverse_grasps=False,
               min_seperation_distance=0.03,
               pc_color=None,
               plasma_coloring=False,
               target_cps=None):
    """
    Draws the 3D scene for the object and the scene.
    Args:
      args: util.make_parser(), parameters needed for data acquisition, grasp, create robot, grasp visualization, etc
      gripper_color: gripper color in rgb
      pc: point cloud of the object
      grasps: list of numpy array indicating the transformation of the grasps: [position, rotation, approaching vector]
      grasp_scores: grasps will be colored based on the scores. If left empty, grasps are visualized in green.
      grasp_color: if it is a tuple, sets the color for all the grasps. If list
        is provided it is the list of tuple(r,g,b) for each grasp.
      mesh: If not None, shows the mesh of the object. Type should be trimesh  mesh.
      show_gripper_mesh: If True, shows the gripper mesh for each grasp.
      visualize_diverse_grasps: sorts the grasps based on score. Selects the
            top score grasp to visualize and then choose grasps that are not within
            min_seperation_distance distance of any of the previously selected
            grasps. Only set it to True to declutter the grasps for better visualization.
      pc_color: if provided, should be a n x 3 numpy array for color of each
        point in the point cloud pc. Each number should be between 0 and 1.
      plasma_coloring: If True, sets the plasma colormap for visualizing the pc.
    """
    if grasps is None:
        grasps = []
    max_grasps = 60
    grasps = np.array(grasps)

    if grasp_scores is not None:
        grasp_scores = np.array(grasp_scores)

    if len(grasps) > max_grasps:
        print('Downsampling grasps, there are too many')
        chosen_ones = np.random.randint(low=0, high=len(grasps), size=max_grasps)
        grasps = grasps[chosen_ones]
        if grasp_scores is not None:
            grasp_scores = grasp_scores[chosen_ones]

    if mesh is not None:
        if type(mesh) == list:
            for elem in mesh:
                plot_mesh(elem)
        else:
            plot_mesh(mesh)

    if pc_color is None and pc is not None:
        if plasma_coloring:
            mlab.points3d(pc[:, 0],
                          pc[:, 1],
                          pc[:, 2],
                          pc[:, 2],  # coloring point according to height
                          colormap='plasma')
        else:
            mlab.points3d(pc[:, 0],
                          pc[:, 1],
                          pc[:, 2],
                          color=(0.1, 0.1, 1),
                          scale_factor=0.01)
    elif pc is not None:
        if plasma_coloring:
            mlab.points3d(pc[:, 0],
                          pc[:, 1],
                          pc[:, 2],
                          pc_color[:, 0],
                          colormap='plasma')
        else:
            rgba = np.zeros((pc.shape[0], 4), dtype=np.uint8)
            rgba[:, :3] = np.asarray(pc_color)
            rgba[:, 3] = 255
            src = mlab.pipeline.scalar_scatter(pc[:, 0], pc[:, 1], pc[:, 2])
            src.add_attribute(rgba, 'colors')
            src.data.point_data.set_active_scalars('colors')
            g = mlab.pipeline.glyph(src)
            g.glyph.scale_mode = "data_scaling_off"
            g.glyph.glyph.scale_factor = 0.01

    grasp_pc = get_grasp_points(args.pc_gripper_version)
    if grasp_scores is None:
        indexes = range(len(grasps))
    else:
        indexes = np.argsort(-np.asarray(grasp_scores))
        min_score = np.min(grasp_scores)
        max_score = np.max(grasp_scores)
        top5 = np.array(grasp_scores).argsort()[-5:][::-1]

    print('draw scene ', len(grasps))

    selected_grasps_so_far = []
    removed = 0

    for ii in range(len(grasps)):
        i = indexes[ii]
        if grasps_selection is not None:
            if grasps_selection[i] is False:
                continue

        g = grasps[i]
        is_diverse = True
        for prevg in selected_grasps_so_far:
            distance = np.linalg.norm(prevg[:3, 3] - g[:3, 3])
            if distance < min_seperation_distance:
                is_diverse = False
                break

        if visualize_diverse_grasps:
            if not is_diverse:
                removed += 1
                continue
            else:
                if grasp_scores is not None:
                    print('selected', i, grasp_scores[i], min_score, max_score)
                else:
                    print('selected', i)
                selected_grasps_so_far.append(g)

        if isinstance(gripper_color, list):
            pass
        elif grasp_scores is not None:
            normalized_score = (grasp_scores[i] - min_score) / (max_score - min_score + 0.0001)
            if grasp_color is not None:
                gripper_color = grasp_color[ii]
            else:
                gripper_color = get_color_plasma(normalized_score)

            if min_score == 1.0:
                gripper_color = (0.0, 1.0, 0.0)

        if show_gripper_mesh:
            if args.grasp_points_file[0] != 'p':
                raise NotImplementedError
            gripper_mesh = Object(
                'panda_gripper.obj').mesh
            gripper_mesh.apply_transform(g)
            mlab.triangular_mesh(
                gripper_mesh.vertices[:, 0],
                gripper_mesh.vertices[:, 1],
                gripper_mesh.vertices[:, 2],
                gripper_mesh.faces,
                color=gripper_color,
                opacity=1 if visualize_diverse_grasps else 0.5)
        else:
            pts = np.matmul(grasp_pc, common.to_rot_mat(g[1]).T)  # rotation
            pts += np.expand_dims(g[0], 0)  # translation
            # print(pts)
            if isinstance(gripper_color, list):
                mlab.plot3d(pts[:, 0],
                            pts[:, 1],
                            pts[:, 2],
                            color=gripper_color[i],
                            tube_radius=0.003,
                            opacity=1)
            else:
                tube_radius = 0.001
                mlab.plot3d(pts[:, 0],
                            pts[:, 1],
                            pts[:, 2],
                            color=gripper_color,
                            tube_radius=tube_radius,
                            opacity=1)
                if target_cps is not None:
                    mlab.points3d(target_cps[ii, :, 0],
                                  target_cps[ii, :, 1],
                                  target_cps[ii, :, 2],
                                  color=(1.0, 0.0, 0),
                                  scale_factor=0.01)

    print('removed {} similar grasps'.format(removed))


def main():
    args = make_parser().parse_args()
    image = cv2.imread(os.path.join(args.data_path, 'rgb.jpg'))
    b, g, r = cv2.split(image)
    image = cv2.merge([r, g, b])
    pc = np.load(os.path.join(args.data_path, 'pc.npy'))
    print('load %s successfully' % os.path.join(args.data_path, 'pc.npy'))
    pc_colors = image.copy()
    pc_colors = np.reshape(pc_colors, [-1, 3])

    # object pos must equal to object pose in data_x/info.txt because point cloud and image are specified already
    if args.method == 'GPNet':
        grasp_poses, grasp_scores = load_pose_GPNet(os.path.join(args.data_path, args.pose_file))
    elif args.method == '6dof-graspnet':
        grasp_poses, grasp_scores = load_pose_6dofgraspnet(os.path.join(args.data_path, args.pose_file))
    else:
        raise NotImplementedError
    print('load %s successfully' % os.path.join(args.data_path, args.pose_file))

    # panda: bottom point is [0, 0, 0]; GPNet: center of two contact points is [0, 0. 0]
    if args.pc_gripper_version == 'panda' and args.method == 'GPNet':
        offset_along_ori = -0.10527
        for center, _, vec in grasp_poses:
            center += pos_offset_along_ori(vec, offset_along_ori)
    # customized: center of two contact points is [0, 0, 0]; 6dof-graspnet: bottom point is [0, 0. 0]
    elif args.pc_gripper_version == 'customized' and args.method == '6dof-graspnet':
        offset_along_ori = 0.10527
        for center, _, vec in grasp_poses:
            center += pos_offset_along_ori(vec, offset_along_ori)

    mlab.figure(bgcolor=(1, 1, 1))
    draw_scene(
        args,
        pc,
        pc_color=pc_colors,
        grasps=grasp_poses,
        grasp_scores=grasp_scores
    )
    mlab.show()


if __name__ == '__main__':
    main()
